= Domain modeling in Scala

== Domain-Driven Design

[%step]
* models (data)
 ** values
 ** entities
 ** events
* behaviors
 ** factories
 ** repositories
 ** services

== Models

=== Value

> An immutalbe object which is only distinquishable by its properties.

[NOTE.speaker]
--
Let's start with an example using build-in types.
--

=== !

[source, scala]
--
val age:  Int    = 18
val name: String = "John Smith"
val cash: Double = 14.56
--

[source, scala]
--
age == age // true
age == (age + 1) // false

name == "John Smish" // true
name == "John Doe" // false

cash == 14.56 // true
cash == 14.57 // false
--

[NOTE.speaker]
--
Values are immutable and they are their identity - any change creates a different value.

The properties are reserves when we start aggregating smaller values into bigger values.
--

=== !

[source, scala]
--
val accountDetails: (Int, String, Double) = (age, name, cash)

accountDetails == accountDetails // true
accountDetails == accountDetails.copy(_1 = 19) // false
--

[NOTE.speaker]
--
This must be true even if we start building on top of them.

(Int, String, Double) is not really descriptive.
--

=== !

[source, scala]
--
type Age = Int
type Name = String
type Cash = Double
--

[source, scala]
--
val age:  Age  = 18
val name: Name = "John Smith"
val cash: Cash = 14.56
--

[NOTE.speaker]
--
Domain-wise built-in types are not descriptive so it's better to encode some information in type.
--

=== !

[source, scala]
--
case class AccountDetails(name: Name, age: Age, cash: Cash)
--

[source, scala]
--
val details = AccountDetails("John Smith", 18, 14.56)

details == details // true
details == details.copy(age = 19) // false
--

[NOTE.speaker]
--
As you can see nothing require us to ensure that name, age, cash is correct.
--

=== !

[source, scala]
--
type Name    = String
type Surname = String

val name:    Name    = "John"
val surname: Surname = name // :(
--

[NOTE.speaker]
--
We can solve this problem by making them separate types.
--

=== !

[source, scala]
--
case class Name(value: String) extends AnyVal
case class Surname(value: String) extends AnyVal

val name:    Name    = Name("John")
val surname: Surname = name // compiler error :)
--

[NOTE.speaker]
--
Now if we mistake 2 values we will get a compile-time error.
--

=== !

[source, scala]
--
case class Email(value: String) extends AnyVal

sealed trait EmailStatus
object EmailStatus {

  case class Confirming(unconfirmed: Email)
      extends EmailStatus

  case class Confirmed(confirmed: Email)
      extends EmailStatus

  case class Changing(old: Email, newUnconfirmed: Email)
      extends EmailStatus
}
--

=== !

[source, scala]
--
val emailStatus: EmailStatus = ...

emailStatus match {
  case EmailStatus.Confirming(unconfirmed) =>
    println(s"Email $unconfirmed is not confirmed yet")
  case EmailStatus.Confirmed(confirmed) =>
    println(s"Email is confirmed $confirmed")
  case EmailStatus.Changing(old, newUnconfirmed) =>
    println(
      s"Old email $old is confirmed" +
        s" but user requested change $newUnconfirmed"
    )
}
--

=== Entity

> An object which has some intrinsic identity, which allows tracing its state's changes in time.

=== !

[source, scala]
--
case class UserId(value: UUID) extends AnyVal
case class Name(value: String) extends AnyVal
case class Surname(value: String) extends AnyVal
case class UserData(name: Name, surname: Surname)

case class User(id: UserId, data: UserData) {

  override def equals(obj: Any): Boolean = obj match {
    case User(otherId, _) => id == otherId
    case _                => false
  }

  override def hashCode: Int = id.hashcode
}
--

=== !

[source, scala]
--
val userId = UserId(UUID.randomUUID)
val data = UserData(Name("John"), Surname("Smith"))
val user = User(userId, data)

user == user // true

import com.softwaremill.quicklens._
user == user.modify(_.data.name).set(Name("Jane")) // true

user == user.copy(id = UserId(UUID.randomUUID)) // false
--

=== Event

> An information that something happened in the system.

[NOTE.speaker]
--
It might be a call, callback, record in ledger (esp in event-sourcing).
--

=== !

[source, scala]
--
case class UserCreationRequested(
  data: UserData
)

case class UserCreated(
  userId: UserId,
  data: UserData,
  at: Instant
)
--

[source, scala]
--
val createUser: UserCreationRequested => UserCreated
--

[NOTE.speaker]
--
How could we model events to separate business process from side effects.
--

== Behaviors

=== Side-effect free

=== !

[source, scala]
--
sealed abstract case class PlanName(value: String) {
  def +(another: PlanName): PlanName =
    new PlanName(value + " " + another.value) {}
}
object PlanName {
  def parse(value: String): Either[String, PlanName] =
    if (value.trim.isEmpty) {
      Left(s"'$value' is not a valid plan name")
    } else Right(new PlanName(value.trim) {})
}
--

[source, scala]
--
import cats.implicits._
val names: Either[String, (PlanName, PlanName)] =
  (PlanName.parse("personal"), PlanName.parse("liability"))
    .tupled
names match {
  case Right((name1, name2)) =>
    println(s"validation succeeded: ${plan1 + plan2}")
  case Left(error) =>
    println(error)
}
// validation succeeded: personal liability
--

[NOTE.speaker]
--
Smart constructors might be treated as a special case of a factory.

First use case for Cats.

[source, scala]
----
import $ivy.`org.typelevel::cats-core:2.1.0`, cats._, cats.data._, cats.implicits._
----
--

=== !

[source, scala]
--
val version2: PlanName = PlanName.parse("version 2").right.get
--

[source, scala]
--
PlanName.parse("household").flatMap { name1 =>
  PlanName.parse(name1.value + " insurance").map { name2 =>
    name2 + version2
  }
}
// Right(PlanName("household insurance version 2"))
--

[source, scala]
--
for {
  name1 <- PlanName.parse("household")
  name2 <- PlanName.parse(name1.value + " insurance")
} yield name2 + version2
--

[NOTE.speaker]
--
Show some examples in REPL here.
--

=== Side effects

=== !

[source, scala]
--
import cats.effect.IO

val program = IO.delay { scala.io.StdIn.readLine }
  .map(PlanName.parse)
  .flatMap {
    case Left(error) => IO.raiseError(new Exception(error))
    case Right(name) => IO.pure(name)
  }
  .map { name => println(s"Valid plan name: $name") }
  .handleError {
    case e: Throwable => e.printStackTrace()
  }
--

[source, scala]
--
program.unsafeRunSync
--

[source, scala]
--
program.unsafeRunAsync { result =>
  println(s"Program finished with: $result")
}
--

[source, scala]
--
program.unsafeToFuture
--

[NOTE.speaker]
--
[source, scala]
----
import $ivy.`org.typelevel::cats-effect:2.1.3`, cats.effect._
----
--
